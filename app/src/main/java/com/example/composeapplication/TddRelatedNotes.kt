package com.example.composeapplication

/*
 What Is a Test?
A test is a manual or automatic procedure used to evaluate if the System Under
Test (SUT) behaves correctly.
The SUT may be a method, an entire class, a module or even a whole application.

Regression:
After adding new functionality or feature, another feature where use to work fine, is broken.

What we should test?
Testing logic of application should be the main goal, but we should write tests
 for code that breaks or will change often.

And what we shouldn't test?
External dependencies and Autogenerated code


TDD:
TDD is a process in which you write the tests for the code you are going to add or
modify before you write the actual code.
In TDD, you start by writing a test. You then write the code to make the test
compile. Next you see that the test fails. Finally, you add the implementation to
the method under test to make it pass.


False positive:
This happens when you have a test that is passing but really shouldn't be.


Unit tests :
Unit tests verify how isolated parts of your application work.
They are the quickest, easiest to write and cheapest to run.
They generally test one outcome of one method at a time.
They are independent of the Android framework.


Robolectric:
Simulates the Android runtime, it allows you to test code that depends
on the framework without using a device or emulator.


Integration tests:
It tests how things work together.

UI tests:
The tests on this layer check if the UI of your application works correctly.

UI Automator:
Google recommends it only when you have to do cross-app functional UI testing
across system and installed apps.

Design patterns:
creational, structural and behavioral

Creational:
describe solutions related to object creation.

    -Singleton: specifies that only one instance of a certain class may exist.
        Usually, it’s possible to access the singleton globally.

    -Builder: abstracts the construction of a complex object, joining several parts.
              avoid an anti-pattern known as a Telescoping Constructor.
              A Telescoping Constructor consists of a constructor with many parameters where
              some of them are optional. This is not an issue with Kotlin where you can have
              default and named parameters.

    -Dependency Injection: This design pattern is crucial to having a testable architecture.
              It favors testability because you can inject fake objects to test different situations.


Structural:
They ease the design to establish relationships between objects.

    -Adapter (or Wrapper): describes how to let two incompatible classes work together.
              example: adapting a list to show it in ui using recyclerview adapter.

    -Facade : defines a high-level interface object which hides the complexity of underlying objects.
              Client objects prefer using the facade instead of the internal objects because
              the facade provides a cleaner, easier-to-use interface.


    -Composite: The intent of the Composite design pattern is to construct complex objects
                composed of individual parts, and to treat the individual parts and the composition
                uniformly.

Behavioral:
explains how objects interact and how a task can be divided into sub-tasks among different objects.
behavioral patterns describe a dynamic flow.

    -Observer: gives us a way to communicate between objects where one object informs
               others about changes or actions.


    -Command: describes the encapsulation of an operation without knowing the real content
              of the operation or the receiver.


(UI)Architectural:
Describes ways to structure and organize your code.
Use them to achieve a robust, stable, testable, modular and easy to extend codebase.

    -MVC: states that each class you write should be part of one of the following layers:
          Model, View, Controller.

    -MVP: Model-View-Presenter

    -MVVM: Model-View-ViewModel


S.O.L.I.D:
    Single responsibility: Each class should have a unique objective or should be useful for a specific case.

    Open-closed:
        The software entities of your app (classes, methods, etc) should be open for extension
         but closed for modification. This means that you should design them in such a way
         that adding new features or modifying behavior shouldn't require you to modify too
         much of your existing code but instead add new code or create new classes

    Liskov substitution:
        states that an app that uses an object of a base class should be able to use objects of derived classes
          without knowing about that and continue working. Therefore, your code should not
          be checking the subtype. In the subclass you can override some of the parent
          methods as long as you continue to comply with its semantics and maintain the
          expected behavior. As you can see, if you respect the contract, the app should
          continue to work. a good example is when we inherit Square class from Rectangle class.
          In your tests created using TDD, everything that you verified for your base class
          should also be verified for your new child class.

    Interface segregation:
        This principle encourages you to create fine grained interfaces that are client
         specific. Suppose you have a class with a few methods, one part of your app may only
         need to access a subset of your methods and other part may need to access another
         subset. This principle encourages you to create two interfaces. Clients should have
         access to only what they need and nothing more.When writing tests using TDD,
         if your class under test has a dependency, it’s easier if you have to stub just
         the methods of a fine grained interface. TDD enforces writing
         more client-focused interfaces, because it makes you think from the client
         perspective — you avoid exposing those methods that won’t be used by the client.

    Dependency inversion
        A concrete class A should not depend on a concrete class B, but an abstraction of B instead.
        This abstraction could be an interface or an abstract class.
        When writing tests using TDD, instead of passing real collaborators (dependencies)
        to a class under test, it’s easier to pass fake objects that conform to the same
        interface. These fake objects could be forced to always behave the same to reproduce
        a specific scenario to test.


 */
